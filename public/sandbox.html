<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sandbox Iframe</title>
  </head>
  <body>
    <script>
      let currentExecutionId = null;
      let timerExecutionIds = {};
      let nextTimerId = 0;
      let timerCallbacks = {};
      let timerMap = {}; // For console.time tracking per execution

      function generateTimerId() {
        return 'timer_' + nextTimerId++;
      }

      // Persistent console overrides
      const originalLog = console.log;
      const originalError = console.error;
      const originalWarn = console.warn;
      const originalDir = console.dir;
      const originalTable = console.table;
      const originalTime = console.time;
      const originalTimeEnd = console.timeEnd;

      console.log = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'log', text, executionId: currentExecutionId }, '*');
        } else {
          originalLog(...args);
        }
      };

      console.error = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'error', text, executionId: currentExecutionId }, '*');
        } else {
          originalError(...args);
        }
      };

      console.warn = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'warn', text, executionId: currentExecutionId }, '*');
        } else {
          originalWarn(...args);
        }
      };

      console.dir = (obj) => {
        if (currentExecutionId) {
          let serialized;
          try {
            serialized = JSON.stringify(obj, null, 2);
          } catch (error) {
            serialized = 'Unserializable object';
          }
          window.parent.postMessage({ type: 'console', subtype: 'dir', data: serialized, executionId: currentExecutionId }, '*');
        } else {
          originalDir(obj);
        }
      };

      console.table = (tabularData) => {
        if (currentExecutionId) {
          let tablePayload;
          try {
            tablePayload = JSON.parse(JSON.stringify(tabularData));
          } catch (error) {
            tablePayload = String(tabularData);
          }
          window.parent.postMessage({ type: 'console', subtype: 'table', data: tablePayload, executionId: currentExecutionId }, '*');
        } else {
          originalTable(tabularData);
        }
      };

      console.time = (label = 'default') => {
        if (currentExecutionId) {
          if (!timerMap[currentExecutionId]) {
            timerMap[currentExecutionId] = {};
          }
          timerMap[currentExecutionId][label] = performance.now();
        } else {
          originalTime(label);
        }
      };

      console.timeEnd = (label = 'default') => {
        if (currentExecutionId && timerMap[currentExecutionId] && timerMap[currentExecutionId][label] !== undefined) {
          const duration = performance.now() - timerMap[currentExecutionId][label];
          window.parent.postMessage({
            type: 'console',
            subtype: 'time',
            label,
            duration: duration.toFixed(2),
            executionId: currentExecutionId,
          }, '*');
          delete timerMap[currentExecutionId][label];
        } else {
          originalTimeEnd(label);
        }
      };

      // Override timer functions persistently
      const originalSetTimeout = window.setTimeout;
      window.setTimeout = (callback, delay = 0, ...args) => {
        const tempId = generateTimerId();
        timerCallbacks[tempId] = () => callback(...args);
        timerExecutionIds[tempId] = currentExecutionId;
        window.parent.postMessage({
          type: 'sandbox-timer-create',
          timerType: 'timeout',
          delay,
          tempId
        }, '*');
        return tempId;
      };

      const originalSetInterval = window.setInterval;
      window.setInterval = (callback, interval = 0, ...args) => {
        const tempId = generateTimerId();
        timerCallbacks[tempId] = () => callback(...args);
        timerExecutionIds[tempId] = currentExecutionId;
        window.parent.postMessage({
          type: 'sandbox-timer-create',
          timerType: 'interval',
          delay: interval,
          tempId
        }, '*');
        return tempId;
      };

      window.clearTimeout = (timerId) => {
        if (timerCallbacks[timerId]) {
          delete timerCallbacks[timerId];
          delete timerExecutionIds[timerId];
          window.parent.postMessage({
            type: 'sandbox-timer-clear',
            timerType: 'timeout',
            timerId
          }, '*');
        }
      };

      window.clearInterval = (timerId) => {
        if (timerCallbacks[timerId]) {
          delete timerCallbacks[timerId];
          delete timerExecutionIds[timerId];
          window.parent.postMessage({
            type: 'sandbox-timer-clear',
            timerType: 'interval',
            timerId
          }, '*');
        }
      };

      // Main message listener for code execution and timer firing
      window.addEventListener('message', (event) => {
        if (event.data && event.data.code && event.data.executionId) {
          currentExecutionId = event.data.executionId;
          const codeToRun = event.data.code;
          try {
            const runnable = new Function(codeToRun);
            runnable();
          } catch (err) {
            window.parent.postMessage({
              type: 'console',
              subtype: 'error',
              text: `Error: ${err.message}`,
              executionId: currentExecutionId
            }, '*');
          } finally {
            window.parent.postMessage({
              type: 'execution-finished',
              executionId: currentExecutionId
            }, '*');
            currentExecutionId = null;
          }
        } else if (event.data && event.data.type === 'sandbox-timer-fire') {
          const { tempId } = event.data;
          const callback = timerCallbacks[tempId];
          if (callback) {
            const savedExecutionId = currentExecutionId;
            currentExecutionId = timerExecutionIds[tempId];
            callback();
            currentExecutionId = savedExecutionId;
          }
        }
      });
    </script>
  </body>
</html>