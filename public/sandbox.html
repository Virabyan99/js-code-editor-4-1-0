<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sandbox Iframe</title>
  </head>
  <body>
    <script>
<<<<<<< HEAD
      let currentExecutionId = null;
      let timerExecutionIds = {};
      let nextTimerId = 0;
      let timerCallbacks = {};
      let timerMap = {}; // For console.time tracking per execution

      function generateTimerId() {
        return 'timer_' + nextTimerId++;
      }
=======
      // Map to store callbacks with their IDs
      let callbackMap = {};
      let nextCallbackId = 0;
      let sendId = 0; // Unique ID for each message send
      let parentWindow; // Store the parent window reference
      let parentOrigin; // Store the parent origin

      // Global error handler for uncaught errors
      window.onerror = function (message, source, lineno, colno, error) {
        if (parentWindow) {
          const errorData = {
            type: "error",
            text: String(message),
            source: String(source),
            lineno,
            colno,
            stack: error && error.stack ? String(error.stack) : null,
          };
          parentWindow.postMessage(
            { sendId: sendId++, messages: [errorData] },
            parentOrigin
          );
        }
        return false; // Allow browser to log error (useful for debugging)
      };

      // Handler for unhandled promise rejections
      window.addEventListener("unhandledrejection", (event) => {
        if (parentWindow) {
          const errorData = {
            type: "error",
            text: `Unhandled Rejection: ${String(event.reason)}`,
            stack:
              event.reason && event.reason.stack
                ? String(event.reason.stack)
                : null,
          };
          parentWindow.postMessage(
            { sendId: sendId++, messages: [errorData] },
            parentOrigin
          );
        }
      });

      window.addEventListener("message", (event) => {
        parentWindow = event.source; // Set parent window reference
        parentOrigin = event.origin; // Set parent origin
>>>>>>> 8a59c8ffe1bff1e2f10b47eb43cbe017e0077245

      // Persistent console overrides
      const originalLog = console.log;
      const originalError = console.error;
      const originalWarn = console.warn;
      const originalDir = console.dir;
      const originalTable = console.table;
      const originalTime = console.time;
      const originalTimeEnd = console.timeEnd;

<<<<<<< HEAD
      console.log = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'log', text, executionId: currentExecutionId }, '*');
        } else {
          originalLog(...args);
        }
      };

      console.error = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'error', text, executionId: currentExecutionId }, '*');
        } else {
          originalError(...args);
        }
      };

      console.warn = (...args) => {
        if (currentExecutionId) {
          const text = args.join(' ');
          window.parent.postMessage({ type: 'console', subtype: 'warn', text, executionId: currentExecutionId }, '*');
        } else {
          originalWarn(...args);
        }
      };

      console.dir = (obj) => {
        if (currentExecutionId) {
=======
        // Store original methods
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        const originalDir = console.dir;
        const originalTable = console.table;
        const originalTime = console.time;
        const originalTimeEnd = console.timeEnd;
        const originalSetTimeout = window.setTimeout;
        const originalSetInterval = window.setInterval;
        const originalClearTimeout = window.clearTimeout;
        const originalClearInterval = window.clearInterval;

        // Override console methods
        console.log = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "log", text });
        };

        console.error = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "error", text });
        };

        console.warn = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "warn", text });
        };

        console.dir = (obj) => {
>>>>>>> 8a59c8ffe1bff1e2f10b47eb43cbe017e0077245
          let serialized;
          try {
            serialized = JSON.stringify(obj, null, 2);
          } catch (error) {
            serialized = "Unserializable object";
          }
<<<<<<< HEAD
          window.parent.postMessage({ type: 'console', subtype: 'dir', data: serialized, executionId: currentExecutionId }, '*');
        } else {
          originalDir(obj);
        }
      };

      console.table = (tabularData) => {
        if (currentExecutionId) {
=======
          messages.push({ type: "dir", data: serialized });
        };

        console.table = (tabularData) => {
>>>>>>> 8a59c8ffe1bff1e2f10b47eb43cbe017e0077245
          let tablePayload;
          try {
            tablePayload = JSON.parse(JSON.stringify(tabularData));
          } catch (error) {
            tablePayload = String(tabularData);
          }
<<<<<<< HEAD
          window.parent.postMessage({ type: 'console', subtype: 'table', data: tablePayload, executionId: currentExecutionId }, '*');
        } else {
          originalTable(tabularData);
=======
          messages.push({ type: "table", data: tablePayload });
        };

        console.time = (label = "default") => {
          timerMap[label] = performance.now();
        };

        console.timeEnd = (label = "default") => {
          if (timerMap[label] !== undefined) {
            const duration = performance.now() - timerMap[label];
            messages.push({
              type: "time",
              label,
              duration: duration.toFixed(2),
            });
            delete timerMap[label];
          } else {
            messages.push({
              type: "warn",
              text: `No such label '${label}' for console.timeEnd()`,
            });
          }
        };

        // Override setTimeout
        window.setTimeout = (callback, delay = 0, ...args) => {
          const callbackId = nextCallbackId++;
          callbackMap[callbackId] = { callback, args, timerType: "timeout" };
          const tempId = Math.random().toString(36).slice(2);
          parentWindow.postMessage(
            {
              type: "sandbox-timer-create",
              timerType: "timeout",
              callbackId,
              delay,
              tempId,
            },
            parentOrigin
          );
          return tempId;
        };

        // Override setInterval
        window.setInterval = (callback, interval = 0, ...args) => {
          const callbackId = nextCallbackId++;
          callbackMap[callbackId] = { callback, args, timerType: "interval" };
          const tempId = Math.random().toString(36).slice(2);
          parentWindow.postMessage(
            {
              type: "sandbox-timer-create",
              timerType: "interval",
              callbackId,
              delay: interval,
              tempId,
            },
            parentOrigin
          );
          return tempId;
        };

        // Override clearTimeout
        window.clearTimeout = (timerId) => {
          parentWindow.postMessage(
            {
              type: "sandbox-timer-clear",
              timerType: "timeout",
              timerId,
            },
            parentOrigin
          );
        };

        // Override clearInterval
        window.clearInterval = (timerId) => {
          parentWindow.postMessage(
            {
              type: "sandbox-timer-clear",
              timerType: "interval",
              timerId,
            },
            parentOrigin
          );
        };

        // Handle incoming messages
        if (typeof event.data === "string") {
          // Execute user code
          try {
            const runnable = new Function(event.data);
            const result = runnable();
            if (result !== undefined) {
              messages.push({ type: "log", text: String(result) });
            }
          } catch (err) {
            messages.push({
              type: "error",
              text: `Error: ${err.message}`,
              stack: err.stack || null,
            });
          }
          parentWindow.postMessage(
            { sendId: sendId++, messages },
            parentOrigin
          );
        } else if (event.data.type === "execute-callback") {
          // Execute timer callback
          const { callbackId } = event.data;
          const { callback, args, timerType } = callbackMap[callbackId] || {};
          if (callback) {
            try {
              callback(...args);
            } catch (err) {
              messages.push({
                type: "error",
                text: `Error in callback: ${err.message}`,
                stack: err.stack || null,
              });
            }
            if (timerType === "timeout") {
              delete callbackMap[callbackId];
            }
            if (messages.length > 0) {
              parentWindow.postMessage(
                { sendId: sendId++, messages },
                parentOrigin
              );
            }
          }
        } else if (event.data.type === "remove-callback") {
          // Remove callback when timer is cleared
          const { callbackId } = event.data;
          delete callbackMap[callbackId];
>>>>>>> 8a59c8ffe1bff1e2f10b47eb43cbe017e0077245
        }
      };

<<<<<<< HEAD
      console.time = (label = 'default') => {
        if (currentExecutionId) {
          if (!timerMap[currentExecutionId]) {
            timerMap[currentExecutionId] = {};
          }
          timerMap[currentExecutionId][label] = performance.now();
        } else {
          originalTime(label);
        }
      };

      console.timeEnd = (label = 'default') => {
        if (currentExecutionId && timerMap[currentExecutionId] && timerMap[currentExecutionId][label] !== undefined) {
          const duration = performance.now() - timerMap[currentExecutionId][label];
          window.parent.postMessage({
            type: 'console',
            subtype: 'time',
            label,
            duration: duration.toFixed(2),
            executionId: currentExecutionId,
          }, '*');
          delete timerMap[currentExecutionId][label];
        } else {
          originalTimeEnd(label);
        }
      };

      // Override timer functions persistently
      const originalSetTimeout = window.setTimeout;
      window.setTimeout = (callback, delay = 0, ...args) => {
        const tempId = generateTimerId();
        timerCallbacks[tempId] = () => callback(...args);
        timerExecutionIds[tempId] = currentExecutionId;
        window.parent.postMessage({
          type: 'sandbox-timer-create',
          timerType: 'timeout',
          delay,
          tempId
        }, '*');
        return tempId;
      };

      const originalSetInterval = window.setInterval;
      window.setInterval = (callback, interval = 0, ...args) => {
        const tempId = generateTimerId();
        timerCallbacks[tempId] = () => callback(...args);
        timerExecutionIds[tempId] = currentExecutionId;
        window.parent.postMessage({
          type: 'sandbox-timer-create',
          timerType: 'interval',
          delay: interval,
          tempId
        }, '*');
        return tempId;
      };

      window.clearTimeout = (timerId) => {
        if (timerCallbacks[timerId]) {
          delete timerCallbacks[timerId];
          delete timerExecutionIds[timerId];
          window.parent.postMessage({
            type: 'sandbox-timer-clear',
            timerType: 'timeout',
            timerId
          }, '*');
        }
      };

      window.clearInterval = (timerId) => {
        if (timerCallbacks[timerId]) {
          delete timerCallbacks[timerId];
          delete timerExecutionIds[timerId];
          window.parent.postMessage({
            type: 'sandbox-timer-clear',
            timerType: 'interval',
            timerId
          }, '*');
        }
      };

      // Main message listener for code execution and timer firing
      window.addEventListener('message', (event) => {
        if (event.data && event.data.code && event.data.executionId) {
          currentExecutionId = event.data.executionId;
          const codeToRun = event.data.code;
          try {
            const runnable = new Function(codeToRun);
            runnable();
          } catch (err) {
            window.parent.postMessage({
              type: 'console',
              subtype: 'error',
              text: `Error: ${err.message}`,
              executionId: currentExecutionId
            }, '*');
          }
          currentExecutionId = null;
        } else if (event.data && event.data.type === 'sandbox-timer-fire') {
          const { tempId } = event.data;
          const callback = timerCallbacks[tempId];
          if (callback) {
            const savedExecutionId = currentExecutionId;
            currentExecutionId = timerExecutionIds[tempId];
            callback();
            currentExecutionId = savedExecutionId;
          }
        }
=======
        // Restore original methods
        console.log = originalLog;
        console.error = originalError;
        console.warn = originalWarn;
        console.dir = originalDir;
        console.table = originalTable;
        console.time = originalTime;
        console.timeEnd = originalTimeEnd;
        window.setTimeout = originalSetTimeout;
        window.setInterval = originalSetInterval;
        window.clearTimeout = originalClearTimeout;
        window.clearInterval = originalClearInterval;
>>>>>>> 8a59c8ffe1bff1e2f10b47eb43cbe017e0077245
      });
    </script>
  </body>
</html>