<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sandbox Iframe</title>
  </head>
  <body>
    <script>
      // Map to store callbacks with their IDs
      let callbackMap = {};
      let nextCallbackId = 0;
      let sendId = 0; // Unique ID for each message send
      let parentWindow; // Store the parent window reference
      let parentOrigin; // Store the parent origin

      // Global error handler for uncaught errors
      window.onerror = function (message, source, lineno, colno, error) {
        if (parentWindow) {
          const errorData = {
            type: "error",
            text: String(message),
            source: String(source),
            lineno,
            colno,
            stack: error && error.stack ? String(error.stack) : null,
          };
          parentWindow.postMessage(
            { sendId: sendId++, messages: [errorData] },
            parentOrigin
          );
        }
        return false; // Allow browser to log error (useful for debugging)
      };

      // Handler for unhandled promise rejections
      window.addEventListener("unhandledrejection", (event) => {
        if (parentWindow) {
          const errorData = {
            type: "error",
            text: `Unhandled Rejection: ${String(event.reason)}`,
            stack:
              event.reason && event.reason.stack
                ? String(event.reason.stack)
                : null,
          };
          parentWindow.postMessage(
            { sendId: sendId++, messages: [errorData] },
            parentOrigin
          );
        }
      });

      window.addEventListener("message", (event) => {
        parentWindow = event.source; // Set parent window reference
        parentOrigin = event.origin; // Set parent origin

        let messages = [];
        let timerMap = {};

        // Store original methods
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        const originalDir = console.dir;
        const originalTable = console.table;
        const originalTime = console.time;
        const originalTimeEnd = console.timeEnd;
        const originalSetTimeout = window.setTimeout;
        const originalSetInterval = window.setInterval;
        const originalClearTimeout = window.clearTimeout;
        const originalClearInterval = window.clearInterval;

        // Override console methods
        console.log = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "log", text });
        };

        console.error = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "error", text });
        };

        console.warn = (...args) => {
          const text = args.join(" ");
          messages.push({ type: "warn", text });
        };

        console.dir = (obj) => {
          let serialized;
          try {
            serialized = JSON.stringify(obj, null, 2);
          } catch (error) {
            serialized = "Unserializable object";
          }
          messages.push({ type: "dir", data: serialized });
        };

        console.table = (tabularData) => {
          let tablePayload;
          try {
            tablePayload = JSON.parse(JSON.stringify(tabularData));
          } catch (error) {
            tablePayload = String(tabularData);
          }
          messages.push({ type: "table", data: tablePayload });
        };

        console.time = (label = "default") => {
          timerMap[label] = performance.now();
        };

        console.timeEnd = (label = "default") => {
          if (timerMap[label] !== undefined) {
            const duration = performance.now() - timerMap[label];
            messages.push({
              type: "time",
              label,
              duration: duration.toFixed(2),
            });
            delete timerMap[label];
          } else {
            messages.push({
              type: "warn",
              text: `No such label '${label}' for console.timeEnd()`,
            });
          }
        };

        // Override setTimeout
        window.setTimeout = (callback, delay = 0, ...args) => {
          const callbackId = nextCallbackId++;
          callbackMap[callbackId] = { callback, args, timerType: "timeout" };
          const tempId = Math.random().toString(36).slice(2);
          parentWindow.postMessage(
            {
              type: "sandbox-timer-create",
              timerType: "timeout",
              callbackId,
              delay,
              tempId,
            },
            parentOrigin
          );
          return tempId;
        };

        // Override setInterval
        window.setInterval = (callback, interval = 0, ...args) => {
          const callbackId = nextCallbackId++;
          callbackMap[callbackId] = { callback, args, timerType: "interval" };
          const tempId = Math.random().toString(36).slice(2);
          parentWindow.postMessage(
            {
              type: "sandbox-timer-create",
              timerType: "interval",
              callbackId,
              delay: interval,
              tempId,
            },
            parentOrigin
          );
          return tempId;
        };

        // Override clearTimeout
        window.clearTimeout = (timerId) => {
          parentWindow.postMessage(
            {
              type: "sandbox-timer-clear",
              timerType: "timeout",
              timerId,
            },
            parentOrigin
          );
        };

        // Override clearInterval
        window.clearInterval = (timerId) => {
          parentWindow.postMessage(
            {
              type: "sandbox-timer-clear",
              timerType: "interval",
              timerId,
            },
            parentOrigin
          );
        };

        // Handle incoming messages
        if (typeof event.data === "string") {
          // Execute user code
          try {
            const runnable = new Function(event.data);
            const result = runnable();
            if (result !== undefined) {
              messages.push({ type: "log", text: String(result) });
            }
          } catch (err) {
            messages.push({
              type: "error",
              text: `Error: ${err.message}`,
              stack: err.stack || null,
            });
          }
          parentWindow.postMessage(
            { sendId: sendId++, messages },
            parentOrigin
          );
        } else if (event.data.type === "execute-callback") {
          // Execute timer callback
          const { callbackId } = event.data;
          const { callback, args, timerType } = callbackMap[callbackId] || {};
          if (callback) {
            try {
              callback(...args);
            } catch (err) {
              messages.push({
                type: "error",
                text: `Error in callback: ${err.message}`,
                stack: err.stack || null,
              });
            }
            if (timerType === "timeout") {
              delete callbackMap[callbackId];
            }
            if (messages.length > 0) {
              parentWindow.postMessage(
                { sendId: sendId++, messages },
                parentOrigin
              );
            }
          }
        } else if (event.data.type === "remove-callback") {
          // Remove callback when timer is cleared
          const { callbackId } = event.data;
          delete callbackMap[callbackId];
        }

        // Restore original methods
        console.log = originalLog;
        console.error = originalError;
        console.warn = originalWarn;
        console.dir = originalDir;
        console.table = originalTable;
        console.time = originalTime;
        console.timeEnd = originalTimeEnd;
        window.setTimeout = originalSetTimeout;
        window.setInterval = originalSetInterval;
        window.clearTimeout = originalClearTimeout;
        window.clearInterval = originalClearInterval;
      });
    </script>
  </body>
</html>